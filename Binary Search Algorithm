BINARY SEARCH or HALF-INTRVAL SEARCH or LOGARITHMIC SEARCH OR BINARY CHOP
First Prerequisite  : Array must be short.
We will apply Divide and conquer rule. O(log n)

import java.util.*;

public class Main
{
	public static void main(String[] args) {
		System.out.println("Hello World");
		int[] arr = {3,6,1,9,4,5,13,10};
		System.out.println(Arrays.toString(arr));  // 3, 6, 1, 9, 4, 5, 13, 10
		arr = bubboleSort(arr);
		System.out.println(Arrays.toString(arr));  //  1, 3, 4, 5, 6, 9, 10, 13
		System.out.println(binarySearch(arr, arr.length, 13));
	}
	
	public static int binarySearch(int[] arr, int length, int data){
	   // System.out.println(length);
	    int first = 0, last = length-1;
	    while(first <= last){
	        System.out.println("First : "+first+" Last : "+last+" "+data);
	        int mid = (first + last) / 2;
	        if(arr[mid] == data)
	            return mid;
	        else if(arr[mid] > data)
	            last = mid - 1;
	        else
	            first = mid + 1;
	    }
	    return -1;
	}
	
	public static int[] bubboleSort(int[] arr){
	    int length = arr.length, temp = 0;
	    boolean flag = true;
	    for(int i = 0; i < length-1-i; i++){
	        //System.out.println("----"+Arrays.toString(arr));
	        for(int j = 0; j < length-1; j++){
	            if(arr[j] > arr[j+1]){
	                temp = arr[j];
	                arr[j] = arr[j+1];
	                arr[j+1] = temp;
	                flag = false;
	            }
	        }
	        if(flag)
	          break;
	    }
	    return arr;
	}
}
// First Prerequisite  : Array must be short.
// We will apply Divide and conquer rule. 

// Time Complixety in Worst-case performance of Linear Search   : O(log n)
// Time Complixety in Average performance of Linear Search      : 0(log n)
// Time Complixety in Best-case performance of Linear Search    : O(1)
// Worst-case space complexity   : 


