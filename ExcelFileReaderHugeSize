

package com.cts.excel;

 

import java.io.File;

import java.io.FileInputStream;

import java.io.FileOutputStream;

import java.io.IOException;

import java.io.InputStream;

import java.io.PrintStream;

import java.util.ArrayList;

import java.util.Arrays;

import java.util.List;

import java.util.Properties;

 

import javax.xml.parsers.ParserConfigurationException;

 

import org.apache.poi.EncryptedDocumentException;

import org.apache.poi.openxml4j.exceptions.InvalidFormatException;

import org.apache.poi.openxml4j.exceptions.OpenXML4JException;

import org.apache.poi.openxml4j.opc.OPCPackage;

import org.apache.poi.openxml4j.opc.PackageAccess;

import org.apache.poi.ss.usermodel.Cell;

import org.apache.poi.ss.usermodel.DataFormatter;

import org.apache.poi.ss.usermodel.Row;

import org.apache.poi.ss.usermodel.WorkbookFactory;

import org.apache.poi.ss.util.CellAddress;

import org.apache.poi.ss.util.CellReference;

import org.apache.poi.util.SAXHelper; // 3.x

import org.apache.poi.xssf.eventusermodel.ReadOnlySharedStringsTable;

import org.apache.poi.xssf.eventusermodel.XSSFReader;

import org.apache.poi.xssf.eventusermodel.XSSFSheetXMLHandler;

import org.apache.poi.xssf.eventusermodel.XSSFSheetXMLHandler.SheetContentsHandler;

import org.apache.poi.xssf.model.StylesTable;

import org.apache.poi.xssf.usermodel.XSSFComment;

import org.apache.poi.xssf.usermodel.XSSFSheet;

import org.apache.poi.xssf.usermodel.XSSFWorkbook;

//import org.apache.poi.util.SAXHelper;

import org.xml.sax.ContentHandler;

import org.xml.sax.InputSource;

import org.xml.sax.SAXException;

import org.xml.sax.XMLReader;

 

//import org.apache.poi.ooxml.util.SAXHelper;  //  4.x

/**

* This class is used to divide the records

*

 * @author  Mithilesh

*

 */

public class ExcelFileReaderHugeSize {

 

            private OPCPackage opcPackage;

            private int minColumns = 0;

            private PrintStream output = null;

            private static List<List<String>> listAllEmpRows = null;

            private int totalRows = 0;

 

           

private static String filePath = “C://abc/abc/x_file";

            private static String outputPath = “C://avc/abs//output/ ";

           

 

            private static String fileName = null;

 

            public static void main(String[] args) {

                        System.out.println("main method start'");

 

                        ExcelFileReaderHugeSize rdhf = new ExcelFileReaderHugeSize();

                        File file = new File(filePath);

                        List<File> listExcels = Arrays.asList(file.listFiles());

                        for (File f : listExcels) {

                                    fileName = f.getName();

                                    rdhf.recordDividerAttributes(f);

                                    outputPath = outputPath + File.separator + fileName;

                        }

                        System.out.println("main method end'");

            }// main

 

            public void recordDividerAttributes(File metadataFile) {

                        System.out.println("recordDividerAttributes()  method start");

                        // check files exist or not

                        if (!metadataFile.exists()) {

                                    System.out.println("Not found or not a file: "

                                                            + metadataFile.getPath());

                        }

                        System.out.println("get File Path  : " + metadataFile.getPath());

                        try {

                                    OPCPackage opcPackage = OPCPackage.open(metadataFile.getPath(),

                                                            PackageAccess.READ);

                                    metadataFile.getAbsolutePath();

                                    this.opcPackage = opcPackage;

                                    this.output = System.out;

                                    process();

                        } catch (Exception e) {

                                    e.printStackTrace();

                                    System.out.println("Error during open huge excel file : "

                                                            + e.getMessage());

                        } finally {

                                    System.out.println("recordDivider finally method");

                                    this.opcPackage = null;

                                    this.output = null;

                        }

                        System.out.println("recordDividerAttributes()  method end");

            }// recordDividerAttributes(-)

 

            private void process() throws IOException, SAXException, OpenXML4JException {

                        System.out.println("process method start");

                        ReadOnlySharedStringsTable strings = new ReadOnlySharedStringsTable(

                                                this.opcPackage);

                        XSSFReader xssfReader = new XSSFReader(this.opcPackage);

                        StylesTable styles = xssfReader.getStylesTable();

                        XSSFReader.SheetIterator iter = (XSSFReader.SheetIterator) xssfReader

                                                .getSheetsData();

                        xssfReader.getSheetsData();

                        int index = 1;

                        // create excel file

                        Row row = null;

                        File file = null;

                        XSSFWorkbook workbook = null;

 

                        file = new File(outputPath);

                        // Blank workbook

                        if (file.exists()) {

                                    try {

                                                workbook = (XSSFWorkbook) WorkbookFactory

                                                                        .create(new FileInputStream(file));

                                    } catch (EncryptedDocumentException | InvalidFormatException e) {

                                                e.printStackTrace();

                                    }

                        } else {

                                    workbook = new XSSFWorkbook();

                        }

                        while (iter.hasNext()) {

                                    totalRows = 0;

                                    int rownum = 0;

                                    listAllEmpRows = new ArrayList<List<String>>();

                                    try {

                                                InputStream stream = iter.next();

                                                String sheetName = iter.getSheetName();

                                                // if(sheetName.equals("Workspace Migration Summary"))

                                                // continue;

                                                System.out.println("Sheet Name : " + sheetName

                                                                        + " , index no =" + index);

                                                processSheet(styles, strings, new SheetToCSV(), stream);

                                                System.out.println("Total no of Rows in current Sheet : "

                                                                        + sheetName + " , Size : " + listAllEmpRows.size());

                                                // Source System Id

                                                if (listAllEmpRows.size() > 1) {

                                                            int listCell = 0;

                                                            boolean flag = true;

                                                            List<String> listSystemId = new ArrayList<String>();

                                                            for (List<String> listR : listAllEmpRows) {

                                                                        if (flag) {

                                                                                    for (String header : listR) {

                                                                                                listCell++;

                                                                                                if (header.equals("Source System Id")) {

                                                                                                            listCell = listCell;

                                                                                                            flag = false;

                                                                                                            break;

                                                                                                }

                                                                                    }

                                                                        }// if

                                                                                    // to jump outer foreach loop

                                                                        if (flag)

                                                                                    break;

                                                                        listSystemId.add(listR.get(listCell - 1));

                                                            }

                                                            System.out.println(listSystemId.size());

                                                            if (listSystemId.size() > 1) {

                                                                        // sort system source Id

 

                                                                        // Create a blank

                                                                        XSSFSheet sheet = workbook.createSheet(sheetName);

                                                                        for (String entry : listSystemId) {

                                                                                    int cellno = 0;

                                                                                    row = sheet.createRow(rownum++);

                                                                                    Cell cell = row.createCell(cellno++);

                                                                                    cell.setCellValue(entry);

                                                                        }

                                                            }

 

                                                }// if

                                    } catch (Exception e) {

                                                e.printStackTrace();

                                    }

                                    ++index;

                                    // clear the list

                                    listAllEmpRows.clear();

                        }// while

                        FileOutputStream out = new FileOutputStream(new File(outputPath));

                        workbook.write(out);

                        out.close();

                        workbook.close();

                        System.out.println("process method end");

            }// process()

 

            private void processSheet(StylesTable styles,

                                    ReadOnlySharedStringsTable strings,

                                    SheetContentsHandler sheetHandler, InputStream sheetInputStream)

                                    throws SAXException, IOException {

                        System.out.println("processSheet method start");

                        DataFormatter formatter = new DataFormatter();

                        InputSource sheetSource = new InputSource(sheetInputStream);

                        try {

                                    XMLReader sheetParser = SAXHelper.newXMLReader();

                                    ContentHandler handler = new XSSFSheetXMLHandler(styles, strings,

                                                            sheetHandler, formatter, false);

                                    sheetParser.setContentHandler(handler);

                                    sheetParser.parse(sheetSource);

                        } catch (ParserConfigurationException e) {

                                    throw new RuntimeException("SAX parser appears to be broken - "

                                                            + e.getMessage());

                        }

                        System.out.println("Total Rows count in Sheet : " + totalRows);

                        System.out.println("processSheet method end");

            }// processSheet(-,-,-,-)

 

            class SheetToCSV implements SheetContentsHandler {

 

                        private int currentRow = -1;

                        private int currentCol = -1;

 

                        private List<String> rowList = null;

 

                        @Override

                        public void cell(String cellReference, String formattedValue,

                                                XSSFComment comment) {

                                    if (cellReference == null) {

                                                cellReference = new CellAddress(currentRow, currentCol)

                                                                        .formatAsString();

                                    }

                                    int thisCol = (new CellReference(cellReference)).getCol();

 

                                    for (int i = rowList.size(); i < thisCol; i++) {

                                                rowList.add(" ");

                                    }

                                    try {

                                                // Double.parseDouble(formattedValue);

                                                rowList.add(formattedValue);

                                    } catch (NumberFormatException e) {

                                                rowList.add(formattedValue);

                                    }

                                    // System.out.println("cell method (-) end");

                        }// cell(-,-,-)

 

                        @Override

                        public void endRow(int rowNum) {

                                    totalRows = rowNum + 1;

                                    listAllEmpRows.add(rowList);

                        }// endRow()

 

                        @Override

                        public void headerFooter(String arg0, boolean arg1, String arg2) {

                                    // System.out.println("headerFooter method (-) start");

 

                                    // System.out.println("headerFooter method (-) end");

                        }// headerFooter(-,-,-)

 

                        @Override

                        public void startRow(int rowNum) {

                                    // System.out.println("startRow method (-) start");

                                    // If there were gaps, output the missing rows

                                    // System.out.println("rn  "+rowNum);

                                    rowList = new ArrayList<String>();

                                    outputMissingRows(rowNum - currentRow - 1);

                                    currentRow = rowNum;

                                    currentCol = -1;

                                    // System.out.println("startRow method (-) end");

                        }// startRow(-)

 

                        private void outputMissingRows(int number) {

                                    // System.out.println("number  "+number);

                                    for (int i = 0; i < number; i++) {

                                                for (int j = 0; j < minColumns; j++) {

                                                            output.append(',');

                                                }

                                                output.append('\n');

                                    }

                        }// outputMissingRows(-)

            }// inner classs

}// outer classs

 
